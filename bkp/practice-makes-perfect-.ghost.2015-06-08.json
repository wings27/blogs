{"db":[{"meta":{"exported_on":1433765647381,"version":"003"},"data":{"app_fields":[],"app_settings":[],"apps":[],"permissions":[{"id":1,"uuid":"ba87c040-e3ca-4968-b72b-c77cf309be43","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":2,"uuid":"2f1d6bf8-329a-4514-adb7-15cd56643898","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":3,"uuid":"804a1d2a-19c7-4e9b-bcab-3c18f73d5004","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":4,"uuid":"0bbb11d9-77ca-4737-9264-adcd890b1751","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":5,"uuid":"e2677773-684a-40e5-9c23-9aebb52a84ec","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":6,"uuid":"494c7b62-3dfa-4e4b-b339-aaaf9f39e326","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":7,"uuid":"015702fa-398c-43a5-9b20-ff966c44ff0e","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":8,"uuid":"c12aa826-c23f-47fa-b01e-1fa4273a1271","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":9,"uuid":"683ffa22-c40e-4980-9d3a-c933ae90fb16","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":10,"uuid":"4a588c60-f767-45e8-9d86-218f70e88d17","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":11,"uuid":"97a13359-d9b1-444c-b354-c10e181053da","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":12,"uuid":"c4099002-784a-4fde-94f4-8d7b103982d7","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":13,"uuid":"7769e41e-1976-4144-b343-0ed27ed996d2","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":14,"uuid":"1d1f6ff7-6005-41c3-bc72-65a0a41d6e38","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":15,"uuid":"cecc6e28-855d-401f-bb7a-7e399ab121ff","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":16,"uuid":"6f5900ed-9c1e-4cd7-af40-4f96e592f7b0","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":17,"uuid":"7afc6ecd-e740-4482-b754-bd91d149bf83","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":18,"uuid":"c1aa2a7b-b2de-4cb8-ae7b-beb3bd7dfd62","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":19,"uuid":"5ab0ea33-d83b-421e-b84a-3376c90d4c81","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":20,"uuid":"a13d3b7d-0467-44ba-a823-0061aa5bbef0","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":21,"uuid":"cd300f5d-cac7-4de0-bb91-a98026cc0040","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":22,"uuid":"c191e67b-38e7-44c9-9644-d73e408743f6","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":23,"uuid":"8e3bffb8-6ff5-4e19-9f3c-35e2f51ab8fd","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":24,"uuid":"9b08f6af-17b3-4d77-8aa9-3b962bac967f","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":25,"uuid":"3c918082-a10e-4b60-82d9-fc9ad2f86638","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":26,"uuid":"de84b6e5-1b3f-487a-a0c1-eb0eeea1218b","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":27,"uuid":"40cb11c2-b29c-4205-8fb3-94c90b2ea8ae","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":28,"uuid":"cdf7bca7-28b1-457a-96d1-4fb40f2a0084","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":29,"uuid":"19a625e0-2f50-42e3-b970-7ffe7677ed85","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1},{"id":30,"uuid":"5567f046-2691-4dd9-ba06-2d696b0ee8c2","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2015-05-20T13:04:03.000Z","created_by":1,"updated_at":"2015-05-20T13:04:03.000Z","updated_by":1}],"permissions_apps":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_users":[],"posts":[{"id":1,"uuid":"a5341c1c-4ad3-4c0e-81af-effba5602926","title":"Welcome to Ghost","slug":"welcome-to-ghost","markdown":"You're live! Nice. We've put together a little post to introduce you to the Ghost editor and get you started. You can manage your content by signing in to the admin area at `<your blog URL>/ghost/`. When you arrive, you can select this post from a list on the left and see a preview of it on the right. Click the little pencil icon at the top of the preview to edit this post and read the next section!\n\n## Getting Started\n\nGhost uses something called Markdown for writing. Essentially, it's a shorthand way to manage your post formatting as you write!\n\nWriting in Markdown is really easy. In the left hand panel of Ghost, you simply write as you normally would. Where appropriate, you can use *shortcuts* to **style** your content. For example, a list:\n\n* Item number one\n* Item number two\n    * A nested item\n* A final item\n\nor with numbers!\n\n1. Remember to buy some milk\n2. Drink the milk\n3. Tweet that I remembered to buy the milk, and drank it\n\n### Links\n\nWant to link to a source? No problem. If you paste in a URL, like http://ghost.org - it'll automatically be linked up. But if you want to customise your anchor text, you can do that too! Here's a link to [the Ghost website](http://ghost.org). Neat.\n\n### What about Images?\n\nImages work too! Already know the URL of the image you want to include in your article? Simply paste it in like this to make it show up:\n\n![The Ghost Logo](https://ghost.org/images/ghost.png)\n\nNot sure which image you want to use yet? That's ok too. Leave yourself a descriptive placeholder and keep writing. Come back later and drag and drop the image in to upload:\n\n![A bowl of bananas]\n\n\n### Quoting\n\nSometimes a link isn't enough, you want to quote someone on what they've said. It was probably very wisdomous. Is wisdomous a word? Find out in a future release when we introduce spellcheck! For now - it's definitely a word.\n\n> Wisdomous - it's definitely a word.\n\n### Working with Code\n\nGot a streak of geek? We've got you covered there, too. You can write inline `<code>` blocks really easily with back ticks. Want to show off something more comprehensive? 4 spaces of indentation gets you there.\n\n    .awesome-thing {\n        display: block;\n        width: 100%;\n    }\n\n### Ready for a Break? \n\nThrow 3 or more dashes down on any new line and you've got yourself a fancy new divider. Aw yeah.\n\n---\n\n### Advanced Usage\n\nThere's one fantastic secret about Markdown. If you want, you can write plain old HTML and it'll still work! Very flexible.\n\n<input type=\"text\" placeholder=\"I'm an input field!\" />\n\nThat should be enough to get you started. Have fun - and let us know what you think :)","html":"<p>You're live! Nice. We've put together a little post to introduce you to the Ghost editor and get you started. You can manage your content by signing in to the admin area at <code>&lt;your blog URL&gt;/ghost/</code>. When you arrive, you can select this post from a list on the left and see a preview of it on the right. Click the little pencil icon at the top of the preview to edit this post and read the next section!</p>\n\n<h2 id=\"gettingstarted\">Getting Started</h2>\n\n<p>Ghost uses something called Markdown for writing. Essentially, it's a shorthand way to manage your post formatting as you write!</p>\n\n<p>Writing in Markdown is really easy. In the left hand panel of Ghost, you simply write as you normally would. Where appropriate, you can use <em>shortcuts</em> to <strong>style</strong> your content. For example, a list:</p>\n\n<ul>\n<li>Item number one</li>\n<li>Item number two\n<ul><li>A nested item</li></ul></li>\n<li>A final item</li>\n</ul>\n\n<p>or with numbers!</p>\n\n<ol>\n<li>Remember to buy some milk  </li>\n<li>Drink the milk  </li>\n<li>Tweet that I remembered to buy the milk, and drank it</li>\n</ol>\n\n<h3 id=\"links\">Links</h3>\n\n<p>Want to link to a source? No problem. If you paste in a URL, like <a href=\"http://ghost.org\">http://ghost.org</a> - it'll automatically be linked up. But if you want to customise your anchor text, you can do that too! Here's a link to <a href=\"http://ghost.org\">the Ghost website</a>. Neat.</p>\n\n<h3 id=\"whataboutimages\">What about Images?</h3>\n\n<p>Images work too! Already know the URL of the image you want to include in your article? Simply paste it in like this to make it show up:</p>\n\n<p><img src=\"https://ghost.org/images/ghost.png\" alt=\"The Ghost Logo\" /></p>\n\n<p>Not sure which image you want to use yet? That's ok too. Leave yourself a descriptive placeholder and keep writing. Come back later and drag and drop the image in to upload:</p>\n\n<h3 id=\"quoting\">Quoting</h3>\n\n<p>Sometimes a link isn't enough, you want to quote someone on what they've said. It was probably very wisdomous. Is wisdomous a word? Find out in a future release when we introduce spellcheck! For now - it's definitely a word.</p>\n\n<blockquote>\n  <p>Wisdomous - it's definitely a word.</p>\n</blockquote>\n\n<h3 id=\"workingwithcode\">Working with Code</h3>\n\n<p>Got a streak of geek? We've got you covered there, too. You can write inline <code>&lt;code&gt;</code> blocks really easily with back ticks. Want to show off something more comprehensive? 4 spaces of indentation gets you there.</p>\n\n<pre><code>.awesome-thing {\n    display: block;\n    width: 100%;\n}\n</code></pre>\n\n<h3 id=\"readyforabreak\">Ready for a Break?</h3>\n\n<p>Throw 3 or more dashes down on any new line and you've got yourself a fancy new divider. Aw yeah.</p>\n\n<hr />\n\n<h3 id=\"advancedusage\">Advanced Usage</h3>\n\n<p>There's one fantastic secret about Markdown. If you want, you can write plain old HTML and it'll still work! Very flexible.</p>\n\n<p><input type=\"text\" placeholder=\"I'm an input field!\" /></p>\n\n<p>That should be enough to get you started. Have fun - and let us know what you think :)</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-20T13:04:02.000Z","created_by":1,"updated_at":"2015-05-21T12:58:41.000Z","updated_by":1,"published_at":"2015-05-20T13:04:02.000Z","published_by":1},{"id":2,"uuid":"c75a2d20-eaaf-46d7-afba-d00f823084cc","title":"你不知道的Linux环境变量","slug":"linux-env","markdown":"Windows上的环境变量配置大家都比较熟悉了，通常我们都会使用系统提供的图形界面来配置，简(shi)单(fen)易(dan)用(teng)。其实Linux上的环境变量配置更为简洁。\n\n#### 环境变量: Windows v.s. Linux\n\n众所周知，Windows的逻辑是系统配置各种扔进注册表里，而Linux的配置通常则是放入文件里。\n\n事实上，以Linux的尿性[^1]，何止配置是文件，简直一切皆文件。[^2]\n\n比如: `cat /dev/urandom > /dev/dsp` 能够在扬声器中播放白噪声。\n\n好玩吧？会玩吗？没玩过吧？[^3]\n\n好像扯远了。。。 \n\nAnyway, Linux 的环境变量配置，正如大家所知道的，只要写入到 `/etc/profile`下就可以了。不过这其实**并不是**推荐的做法。\n\n想知道原因，首先需要了解一下Linux下环境配置文件的加载顺序。\n\n#### Linux 环境配置加载顺序 (以CentOS 7 为例)\nLinux通常有以下几个环境配置文件：\n\n- /etc/profile\n- /etc/profile.d/*.sh\n- ~/.bash_profile\n- ~/.bashrc\n- /etc/bashrc\n\n不同场景下配置文件加载的机制也不同，这里我们分情况来说。\n\n1. 用户正常登录（密码或公钥）进入bash环境。\n加载顺序： \n    `/etc/profile` > `/etc/profile.d/*.sh` > `~/.bash_profile` > `~/.bashrc` > `/etc/bashrc`\n\n2. 使用su切换用户，如 su someuser\n加载顺序：\n`~/.bashrc` > `/etc/bashrc` > `/etc/profile.d/*.sh`\n\n3. ssh连接至非交互环境执行命令\n加载顺序(与2相同)：\n`~/.bashrc` > `/etc/bashrc` > `/etc/profile.d/*.sh`\n\n并且Linux环境加载某个配置文件时，该文件内部有主动加载的配置也会同步地加载（就像传统的方法调用那样），比如 /etc/profile.d/lang.sh 可能会加载 /etc/sysconfig/i18n\n\n以及后面声明的环境变量值会覆盖掉之前的同名变量。\n\n#### 验证\n在我的机器(CentOS 7.0) 上做测试，编辑上述文件，加入不同的环境变量，赋值为当前时间。\n\n例如在`/etc/profile`行首加入: \n\n    export TEST_ETC_PROFILE=`date +'%c %N'`\n\n其余以此类推。\n\n##### 测试结果：\n![测试结果](http://img.blog.csdn.net/20150513234734253)\n\n从时间戳可以看出，上述加载顺序是正确的。\n\n#### 结论\n\n1. 原则上**不推荐**对`/etc/profile`做任何更改，（在`/etc/profile` 头部的注释中就能看到），主要应该是基于维护成本考虑。\n\n2. `/etc/profile.d/*.sh`总是会加载，无论是登录进入bash还是su进入bash都会加载，因此**系统级别**的变量配置脚本推荐放入`/etc/profile.d/`下。（注意后缀名和权限）。\n\n3. 对bash本身的自定义配置推荐写在`~/.bash_profile`里。\n\n4. 自写自用的辅助脚本需要加到`$PATH`的（如 `PATH=$PATH:/opt/scripts` ），推荐写在`~/.bashrc`里。需要多用户共用的，则放在`/etc/bashrc`里。\n\n更多详情参见 CentOS官方文档 [^4] , 解释比较全面，好顶赞！\n\n#### 参考文献\n[^1]: [尿性_互动百科](http://www.baike.com/wiki/%E5%B0%BF%E6%80%A7)\n\n[^2]: [知乎 - Linux 下 “一切皆文件” 思想的本质和好处在哪里？](http://www.zhihu.com/question/25696682)\n\n[^3]: [《主角与配角》经典台词](http://baike.baidu.com/view/598090.htm)\n\n[^4]: [Configuration / Environment Variables | CentOS HowTos](http://centoshowtos.org/environment-variables/)\n","html":"<p>Windows上的环境变量配置大家都比较熟悉了，通常我们都会使用系统提供的图形界面来配置，简(shi)单(fen)易(dan)用(teng)。其实Linux上的环境变量配置更为简洁。</p>\n\n<h4 id=\"windowsvslinux\">环境变量: Windows v.s. Linux</h4>\n\n<p>众所周知，Windows的逻辑是系统配置各种扔进注册表里，而Linux的配置通常则是放入文件里。</p>\n\n<p>事实上，以Linux的尿性<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\">1</a></sup>，何止配置是文件，简直一切皆文件。<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\">2</a></sup></p>\n\n<p>比如: <code>cat /dev/urandom &gt; /dev/dsp</code> 能够在扬声器中播放白噪声。</p>\n\n<p>好玩吧？会玩吗？没玩过吧？<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\">3</a></sup></p>\n\n<p>好像扯远了。。。 </p>\n\n<p>Anyway, Linux 的环境变量配置，正如大家所知道的，只要写入到 <code>/etc/profile</code>下就可以了。不过这其实<strong>并不是</strong>推荐的做法。</p>\n\n<p>想知道原因，首先需要了解一下Linux下环境配置文件的加载顺序。</p>\n\n<h4 id=\"linuxcentos7\">Linux 环境配置加载顺序 (以CentOS 7 为例)</h4>\n\n<p>Linux通常有以下几个环境配置文件：</p>\n\n<ul>\n<li>/etc/profile</li>\n<li>/etc/profile.d/*.sh</li>\n<li>~/.bash_profile</li>\n<li>~/.bashrc</li>\n<li>/etc/bashrc</li>\n</ul>\n\n<p>不同场景下配置文件加载的机制也不同，这里我们分情况来说。</p>\n\n<ol>\n<li><p>用户正常登录（密码或公钥）进入bash环境。 <br />\n加载顺序： \n<code>/etc/profile</code> > <code>/etc/profile.d/*.sh</code> > <code>~/.bash_profile</code> > <code>~/.bashrc</code> > <code>/etc/bashrc</code></p></li>\n<li><p>使用su切换用户，如 su someuser <br />\n加载顺序：\n<code>~/.bashrc</code> > <code>/etc/bashrc</code> > <code>/etc/profile.d/*.sh</code></p></li>\n<li><p>ssh连接至非交互环境执行命令 <br />\n加载顺序(与2相同)：\n<code>~/.bashrc</code> > <code>/etc/bashrc</code> > <code>/etc/profile.d/*.sh</code></p></li>\n</ol>\n\n<p>并且Linux环境加载某个配置文件时，该文件内部有主动加载的配置也会同步地加载（就像传统的方法调用那样），比如 /etc/profile.d/lang.sh 可能会加载 /etc/sysconfig/i18n</p>\n\n<p>以及后面声明的环境变量值会覆盖掉之前的同名变量。</p>\n\n<h4 id=\"\">验证</h4>\n\n<p>在我的机器(CentOS 7.0) 上做测试，编辑上述文件，加入不同的环境变量，赋值为当前时间。</p>\n\n<p>例如在<code>/etc/profile</code>行首加入: </p>\n\n<pre><code>export TEST_ETC_PROFILE=`date +'%c %N'`\n</code></pre>\n\n<p>其余以此类推。</p>\n\n<h5 id=\"\">测试结果：</h5>\n\n<p><img src=\"http://img.blog.csdn.net/20150513234734253\" alt=\"测试结果\" /></p>\n\n<p>从时间戳可以看出，上述加载顺序是正确的。</p>\n\n<h4 id=\"\">结论</h4>\n\n<ol>\n<li><p>原则上<strong>不推荐</strong>对<code>/etc/profile</code>做任何更改，（在<code>/etc/profile</code> 头部的注释中就能看到），主要应该是基于维护成本考虑。</p></li>\n<li><p><code>/etc/profile.d/*.sh</code>总是会加载，无论是登录进入bash还是su进入bash都会加载，因此<strong>系统级别</strong>的变量配置脚本推荐放入<code>/etc/profile.d/</code>下。（注意后缀名和权限）。</p></li>\n<li><p>对bash本身的自定义配置推荐写在<code>~/.bash_profile</code>里。</p></li>\n<li><p>自写自用的辅助脚本需要加到<code>$PATH</code>的（如 <code>PATH=$PATH:/opt/scripts</code> ），推荐写在<code>~/.bashrc</code>里。需要多用户共用的，则放在<code>/etc/bashrc</code>里。</p></li>\n</ol>\n\n<p>更多详情参见 CentOS官方文档 <sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\">4</a></sup> , 解释比较全面，好顶赞！</p>\n\n<h4 id=\"\">参考文献</h4>\n\n<div class=\"footnotes\"><ol><li class=\"footnote\" id=\"fn:1\"><p><a href=\"http://www.baike.com/wiki/%E5%B0%BF%E6%80%A7\">尿性_互动百科</a> <a href=\"#fnref:1\" title=\"return to article\">↩</a></p></li>\n\n<li class=\"footnote\" id=\"fn:2\"><p><a href=\"http://www.zhihu.com/question/25696682\">知乎 - Linux 下 “一切皆文件” 思想的本质和好处在哪里？</a> <a href=\"#fnref:2\" title=\"return to article\">↩</a></p></li>\n\n<li class=\"footnote\" id=\"fn:3\"><p><a href=\"http://baike.baidu.com/view/598090.htm\">《主角与配角》经典台词</a> <a href=\"#fnref:3\" title=\"return to article\">↩</a></p></li>\n\n<li class=\"footnote\" id=\"fn:4\"><p><a href=\"http://centoshowtos.org/environment-variables/\">Configuration / Environment Variables | CentOS HowTos</a> <a href=\"#fnref:4\" title=\"return to article\">↩</a></p></li></ol></div>","image":"","featured":0,"page":0,"status":"published","language":"en_US","meta_title":"Linux环境变量配置 CentOS7安装 Java环境配置","meta_description":"Linux通常有以下几个环境配置文件：/etc/profile /etc/profile.d/*.sh...不同场景下配置文件加载的机制也不同，这里我们分情况来说。1. 用户正常登录（密码或公钥）进入bash环境。加载顺序：`/etc/profile` > `/etc/profile.d/*.sh` 2.","author_id":1,"created_at":"2015-05-20T14:21:53.000Z","created_by":1,"updated_at":"2015-05-26T15:22:25.000Z","updated_by":1,"published_at":"2015-05-20T15:30:00.000Z","published_by":1},{"id":3,"uuid":"edbcc699-0770-4526-b14d-b495bf5a5f7d","title":"利用Windows映像劫持实现默认程序的替换","slug":"windows-ifeo","markdown":"众所周知，Windows NT内核的系统（Windows XP, Windows 7 等）拥有一项叫做IFEO的神奇技术，俗称映像劫持。本来是用于加载调试器的[^1]，不过我们也可以另辟蹊径，利用这一机制来替换系统默认程序关联。\n\n#### 文件关联\n\n我们可能都遇到过需要更改系统默认文件关联的情况。比如想用我们心爱的编辑器打开所有文本类型的文件。这就需要了解Windows的文件关联。\n\n简单解释一下，Windows的资源管理器识别文件类型是由扩展名决定的（而并不是文件头决定文件类型）。首先扩展名会对应一种文件类型，这种文件类型的不同操作再对应到不同的具体命令。\n\n比如： `.txt --> txtfile --> { \"open\": \"notepad.exe %1\", \"edit\": \"notepad.exe %1\", ... }`\n\n这些对应关系保存于注册表的`HKEY_CLASSES_ROOT`项，由Explorer读取后，决定文件该用什么命令处理。\n\n文件扩展名与文件类型的对应关系，可以通过`assoc`命令查看或修改。\n\n例如：\n\n- 查看后缀关联：\n\n `assoc .txt`\n> .txt=txtfile\n\n- 新增/更改关联：\n\n `assoc .json=txtfile`\n> .jpg=txtfile\n\n- 删除关联：\n\n `assoc .json=`\n> (无返回内容)\n\n文件类型与open command的对应关系，可以通过`ftype`命令查看或修改。用法与`assoc`类似，使用`%1`表示目标文件，`%2`等表示其他参数，`%*`代表所有参数。\n例如：\n\n`ftype txtfile`\n> txtfile=%SystemRoot%\\system32\\NOTEPAD.EXE %1\n\n进而，文件扩展名就与相应程序关联上了。\n\n*以上的命令只改变扩展名对应的打开方式，文件类型的其他相关信息不受影响。*\n\n#### 使用IFEO\n\n我们发现，想使用指定程序打开特定后缀的文件，只需 `assoc` 和 `ftype` 就可以搞定了。\n\n`assoc .json=txtfile`\n\n`ftype txtfile=MY_FAVOURITE_EDITOR.exe %1`\n\n不过这种方案只能更改open command。比如.bat后缀的批处理文件，右键点击编辑，还是用回（很挫的）notepad打开了。\n\n于是很自然想到另一个方案，干脆用我们的编辑器替换掉notepad.exe算了。不过这样做的缺陷也显而易见。何况 XP系统还可能触发系统文件保护机制。\n\n因此，更好的办法是使用IFEO，以加载“调试器”的形式，在运行时“替换”掉系统默认程序。这样既不会产生新文件（符号链接），也不会改动系统文件。\n\n#### 详细操作\n\n使用IFEO很简单。注册表定位到\n\n`HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe`\n\n（注意其中的Windows NT）\n\n创建Debugger字符串值(REG_SZ)，更改其值为`MY_FAVOURITE_EDITOR.exe -z`\n\n就可以了。\n\n这里的\"-z\"参数表示跳过后面的参数，如果不加这个参数，Sublime Text就会同时打开notepad.exe本身，因为后者是作为被调试的程序传参传入Sublime Text的。\n\n\"-z\"参数适用于Sublime Text。如果使用Notepad2，则\"-z\"参数要改为\"/z\". \n\n至于Notepad++, 暂时无解，可以尝试用AutoHotKey实现该功能。\n\n至此，使用IFEO替换默认编辑器就已经完成了。快去开心地撸代码吧！\n\n#### 参考文献\n[^1]: [Launching the Debugger Automatically - MSDN](https://msdn.microsoft.com/en-us/library/a329t4ed%28VS.71%29.aspx)\n","html":"<p>众所周知，Windows NT内核的系统（Windows XP, Windows 7 等）拥有一项叫做IFEO的神奇技术，俗称映像劫持。本来是用于加载调试器的<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\">1</a></sup>，不过我们也可以另辟蹊径，利用这一机制来替换系统默认程序关联。</p>\n\n<h4 id=\"\">文件关联</h4>\n\n<p>我们可能都遇到过需要更改系统默认文件关联的情况。比如想用我们心爱的编辑器打开所有文本类型的文件。这就需要了解Windows的文件关联。</p>\n\n<p>简单解释一下，Windows的资源管理器识别文件类型是由扩展名决定的（而并不是文件头决定文件类型）。首先扩展名会对应一种文件类型，这种文件类型的不同操作再对应到不同的具体命令。</p>\n\n<p>比如： <code>.txt --&gt; txtfile --&gt; { \"open\": \"notepad.exe %1\", \"edit\": \"notepad.exe %1\", ... }</code></p>\n\n<p>这些对应关系保存于注册表的<code>HKEY_CLASSES_ROOT</code>项，由Explorer读取后，决定文件该用什么命令处理。</p>\n\n<p>文件扩展名与文件类型的对应关系，可以通过<code>assoc</code>命令查看或修改。</p>\n\n<p>例如：</p>\n\n<ul>\n<li><p>查看后缀关联：</p>\n\n<p><code>assoc .txt</code></p>\n\n<blockquote>\n  <p>.txt=txtfile</p>\n</blockquote></li>\n<li><p>新增/更改关联：</p>\n\n<p><code>assoc .json=txtfile</code></p>\n\n<blockquote>\n  <p>.jpg=txtfile</p>\n</blockquote></li>\n<li><p>删除关联：</p>\n\n<p><code>assoc .json=</code></p>\n\n<blockquote>\n  <p>(无返回内容)</p>\n</blockquote></li>\n</ul>\n\n<p>文件类型与open command的对应关系，可以通过<code>ftype</code>命令查看或修改。用法与<code>assoc</code>类似，使用<code>%1</code>表示目标文件，<code>%2</code>等表示其他参数，<code>%*</code>代表所有参数。\n例如：</p>\n\n<p><code>ftype txtfile</code></p>\n\n<blockquote>\n  <p>txtfile=%SystemRoot%\\system32\\NOTEPAD.EXE %1</p>\n</blockquote>\n\n<p>进而，文件扩展名就与相应程序关联上了。</p>\n\n<p><em>以上的命令只改变扩展名对应的打开方式，文件类型的其他相关信息不受影响。</em></p>\n\n<h4 id=\"ifeo\">使用IFEO</h4>\n\n<p>我们发现，想使用指定程序打开特定后缀的文件，只需 <code>assoc</code> 和 <code>ftype</code> 就可以搞定了。</p>\n\n<p><code>assoc .json=txtfile</code></p>\n\n<p><code>ftype txtfile=MY_FAVOURITE_EDITOR.exe %1</code></p>\n\n<p>不过这种方案只能更改open command。比如.bat后缀的批处理文件，右键点击编辑，还是用回（很挫的）notepad打开了。</p>\n\n<p>于是很自然想到另一个方案，干脆用我们的编辑器替换掉notepad.exe算了。不过这样做的缺陷也显而易见。何况 XP系统还可能触发系统文件保护机制。</p>\n\n<p>因此，更好的办法是使用IFEO，以加载“调试器”的形式，在运行时“替换”掉系统默认程序。这样既不会产生新文件（符号链接），也不会改动系统文件。</p>\n\n<h4 id=\"\">详细操作</h4>\n\n<p>使用IFEO很简单。注册表定位到</p>\n\n<p><code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe</code></p>\n\n<p>（注意其中的Windows NT）</p>\n\n<p>创建Debugger字符串值(REG_SZ)，更改其值为<code>MY_FAVOURITE_EDITOR.exe -z</code></p>\n\n<p>就可以了。</p>\n\n<p>这里的\"-z\"参数表示跳过后面的参数，如果不加这个参数，Sublime Text就会同时打开notepad.exe本身，因为后者是作为被调试的程序传参传入Sublime Text的。</p>\n\n<p>\"-z\"参数适用于Sublime Text。如果使用Notepad2，则\"-z\"参数要改为\"/z\". </p>\n\n<p>至于Notepad++, 暂时无解，可以尝试用AutoHotKey实现该功能。</p>\n\n<p>至此，使用IFEO替换默认编辑器就已经完成了。快去开心地撸代码吧！</p>\n\n<h4 id=\"\">参考文献</h4>\n\n<div class=\"footnotes\"><ol><li class=\"footnote\" id=\"fn:1\"><p><a href=\"https://msdn.microsoft.com/en-us/library/a329t4ed%28VS.71%29.aspx\">Launching the Debugger Automatically - MSDN</a> <a href=\"#fnref:1\" title=\"return to article\">↩</a></p></li></ol></div>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-26T14:54:57.000Z","created_by":1,"updated_at":"2015-06-01T16:19:17.000Z","updated_by":1,"published_at":"2015-05-26T16:32:59.000Z","published_by":1},{"id":4,"uuid":"3289334e-3905-47a4-a025-0becd24bed14","title":"C#跨线程修改控件——从MSIL和汇编看事件委托","slug":"win-form-event-delegate","markdown":"#### 跨线程修改控件的问题\n相信大家刚开始写winform的时候都遇到过这样的问题，当跨线程修改控件属性时会遇到如下的异常：\n\n> 线程间操作无效: 从不是创建控件\"progressBar1\"的线程访问它。\n\n这是相应的产生上述异常的示例代码（注意事件响应部分）：\n\n`Director.cs`的内容:\n\n```C#\n\n// DelegateDemo - Director.cs\n// by Wings\n// Last Modified : 2013-05-28 11:43\n\nusing System.Globalization;\nusing System.Threading;\n\nnamespace DelegateDemo\n{\n    public delegate void PostEventHandler(string postStatus);\n\n    internal class Director\n    {\n        private static PostEventHandler _report;\n\n        public event PostEventHandler OnReport\n        {\n            add { _report += value; }\n            remove { _report -= value; }\n        }\n\n        public static void Test()\n        {\n            int counter = 0;\n            while (counter++ < 100)\n            {\n                _report(counter.ToString());\n                Thread.Sleep(100);\n            }\n        }\n    }\n}\n```\n\n`Form1.cs`的内容:\n\n```C#\n\n  // DelegateDemo - Form1.cs\n  // by Wings\n  // Last Modified : 2013-05-27 19:54\n  \n  using System;\n  using System.Threading;\n  using System.Windows.Forms;\n  \n  namespace DelegateDemo\n  {\n      public partial class Form1 : Form\n      {\n          public Form1()\n          {\n              InitializeComponent();\n          }\n  \n          private void button1_Click(object sender, EventArgs e)\n          {\n              Director director = new Director();\n              director.OnReport += director_OnReport;\n              Thread thread = new Thread(Director.Test)\n                              {\n                                  Name = \"thdDirector\"\n                              };\n              thread.Start();\n          }\n  \n          private void director_OnReport(string postStatus)\n          {\n              int value = Convert.ToInt32(postStatus);\n              this.progressBar1.Value = value;  //此处产生异常\n          }\n      }\n  }\n```\n\n我们知道多线程下处于竞态条件（Race Condition[^1]）的资源状态同步可能出现冲突。因此CLR才会禁止这种跨线程修改主窗体控件的行为。\n\n一个简单粗暴（但十分有效）的方法是在主窗体构造函数中加入\n`CheckForIllegalCrossThreadCalls = false;`\n\n像这样：\n\n```C#\npublic Form1()\n{            \n    InitializeComponent();\n    CheckForIllegalCrossThreadCalls = false;\n}\n```\n\n附上msdn的解释[^2]：\n\n> CheckForIllegalCrossThreadCalls: 获取或设置一个值，该值指示是否捕获对错误线程的调用，这些调用在调试应用程序时访问控件的 Handle 属性。\n因此设为false后将不再检查非法跨线程调用。 \n\n然而毕竟跨线程调用是不安全的，可能导致同步失败。所以我们采用正统一点的方法来解决，那就是调用控件的`Invoke()`或`BeginInvoke()`方法。\n\n二者的差别在于`BeginInvoke()`是异步的，这里为了防止`Director.Test()`执行时主窗体关闭导致句柄失效而产生异常，我们使用`BeginInvoke()`方法进行异步调用。\n\n#### 通过Invoke解决问题\n\n更改过的`Form1.cs`:\n\n```C#\n\n // DelegateDemo - Form1.cs\n // by Wings\n // Last Modified : 2013-05-28 13:06\n \n using System;\n using System.Threading;\n using System.Windows.Forms;\n \n namespace DelegateDemo\n {\n     public partial class Form1 : Form\n     {\n         public Form1()\n         {\n             InitializeComponent();\n         }\n \n         private void button1_Click(object sender, EventArgs e)\n         {\n             Director director = new Director();\n             director.OnReport += director_OnReport;\n             Thread thread = new Thread(Director.Test)\n                             {\n                                 Name = \"thdDirector\"\n                             };\n             thread.Start();\n         }\n \n         private void director_OnReport(string postStatus)\n         {\n             int value = Convert.ToInt32(postStatus);\n             if (this.progressBar1.InvokeRequired)\n             {\n                 SetValueCallback setValueCallback = delegate(int i)\n                                                     {\n                                                         this.progressBar1.Value = i;\n                                                     };\n                 this.progressBar1.BeginInvoke(setValueCallback, value);\n             }\n             else\n             {\n                 this.progressBar1.Value = value;\n             }\n         }\n \n         private delegate void SetValueCallback(int value);\n     }\n }\n```\n\n至此，问题已经彻底解决，本文也可以结束了。\n\n但是！！！我们都知道一个不想当Geek的码农不是合格的程序猿~\n\n于是再次发扬Geek精神，尝试剥去.NET粉饰的外衣，窥其真理的内核。\n\n#### 源码分析\n\n先从`Invoke()`入手，看源码：\n\n```C#\npublic object Invoke(Delegate method, params object[] args)\n{\n    using (new Control.MultithreadSafeCallScope())\n    return this.FindMarshalingControl().MarshaledInvoke(this, method, args, true);\n}\n```\n\n而`BeginInvoke()`差别仅仅在于`MarshaledInvoke()`的参数是否`synchronous`:\n\n```C#\npublic IAsyncResult BeginInvoke(Delegate method, params object[] args)\n{\n      using (new Control.MultithreadSafeCallScope())\n        return (IAsyncResult) this.FindMarshalingControl().MarshaledInvoke(this, method, args, false);\n}\n```\n\n实质都是调用了`MarshaledInvoke`方法。\n\nMarshaled这个词常写Native Methods的同学一定很熟悉。对应的中文翻译我。。不知道。。 貌似是叫“编组”。\n\n给出维基百科的释义[^3]作为参考吧：\n\n>In computer science, marshalling (sometimes spelled marshaling with a single l) is the process of transforming the memory representation of an object to a data format suitable for storage or transmission, and it is typically used when data must be moved between different parts of a computer program or from one program to another. Marshalling is similar to serialization and is used to communicate to remote objects with an object, in this case a serialized object. It simplifies complex communication, using custom/complex objects to communicate instead of primitives. The opposite, or reverse, of marshalling is called unmarshalling (or demarshalling, similar to deserialization).\n\n所以.NET的“暗箱操作”很有可能就在`MarshaledInvoke`里面。我们点进去看一下，当然主要关注NativeMethods\n\n```C#\nprivate object MarshaledInvoke(Control caller, Delegate method, object[] args, bool synchronous)\n    {\n      if (!this.IsHandleCreated)\n        throw new InvalidOperationException(System.Windows.Forms.SR.GetString(\"ErrorNoMarshalingThread\"));\n      if ((Control.ActiveXImpl) this.Properties.GetObject(Control.PropActiveXImpl) != null)\n        System.Windows.Forms.IntSecurity.UnmanagedCode.Demand();\n      bool flag = false;\n      int lpdwProcessId;\n      if (System.Windows.Forms.SafeNativeMethods.GetWindowThreadProcessId(new HandleRef((object) this, this.Handle), out lpdwProcessId) == System.Windows.Forms.SafeNativeMethods.GetCurrentThreadId() && synchronous)\n        flag = true;\n      ExecutionContext executionContext = (ExecutionContext) null;\n      if (!flag)\n        executionContext = ExecutionContext.Capture();\n      Control.ThreadMethodEntry threadMethodEntry = new Control.ThreadMethodEntry(caller, this, method, args, synchronous, executionContext);\n      lock (this)\n      {\n        if (this.threadCallbackList == null)\n          this.threadCallbackList = new Queue();\n      }\n      lock (this.threadCallbackList)\n      {\n        if (Control.threadCallbackMessage == 0)\n          Control.threadCallbackMessage = System.Windows.Forms.SafeNativeMethods.RegisterWindowMessage(Application.WindowMessagesVersion + \"_ThreadCallbackMessage\");\n        this.threadCallbackList.Enqueue((object) threadMethodEntry);\n      }\n      if (flag)\n        this.InvokeMarshaledCallbacks();\n      else\n       // 这里就是纯天然原生态NativeMethod\n      System.Windows.Forms.UnsafeNativeMethods.PostMessage(new HandleRef((object) this, this.Handle), Control.threadCallbackMessage, IntPtr.Zero, IntPtr.Zero);\n      if (!synchronous)\n        return (object) threadMethodEntry;\n      if (!threadMethodEntry.IsCompleted)\n        this.WaitForWaitHandle(threadMethodEntry.AsyncWaitHandle);\n      if (threadMethodEntry.exception != null)\n        throw threadMethodEntry.exception;\n      else\n        return threadMethodEntry.retVal;\n}\n```\n\n果然找到了，这个`System.Windows.Forms.UnsafeNativeMethods.PostMessage()`就是WinAPI封装过后的NativeMethod了。当然它披上另一件衣服之后也是MFC里面的`CWnd::PostMessage`, 负责向窗体消息队列中放置一条消息，并且不等待消息被处理而直接返回（异步也是与`SendMessage`的主要差别）。\n\nMSDN文档[^4]：\n> Places a message in the window's message queue and then returns without waiting for the corresponding window to process the message.\n\n这也就解释了上述情况发生的原因，调用`Invoke()`而不是直接更改控件值使得主窗体能够将消息加入自身的消息队列中，从而在合适的时间处理消息，这样跨线程更改控件值就转变为窗体线程自己更改控件值，也就是从创建控件的线程（窗体主线程）访问控件，避免了之前的错误。\n\n#### InvokeRequired属性探究\n还有一个问题，如果本来就是窗体线程对控件进行访问呢，毫无疑问直接设置值即可。在上面的代码中我使用InvokeRequired属性来判断控件更改者是否来自于其他线程，从而决定是调`Invoke()`还是直接改。那么这个属性是否真的如我们所想，仅仅是判断调用者线程呢？看代码：\n\n`InvokeRequired:`\n\n```C#\n[SRDescription(\"ControlInvokeRequiredDescr\")]\n[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]\n[Browsable(false)]\n[EditorBrowsable(EditorBrowsableState.Advanced)]\npublic bool InvokeRequired\n{\n      get\n      {\n        using (new Control.MultithreadSafeCallScope())\n        {\n          HandleRef hWnd;\n          if (this.IsHandleCreated)\n          {\n            hWnd = new HandleRef((object) this, this.Handle);\n          }\n          else\n          {\n            Control marshalingControl = this.FindMarshalingControl();\n            if (!marshalingControl.IsHandleCreated)\n              return false;\n            hWnd = new HandleRef((object) marshalingControl, marshalingControl.Handle);\n          }\n          int lpdwProcessId;\n          return System.Windows.Forms.SafeNativeMethods.GetWindowThreadProcessId(hWnd, out lpdwProcessId) != System.Windows.Forms.SafeNativeMethods.GetCurrentThreadId();\n        }\n      }\n    }\n```\n\n果然如此，最后的return写得很清楚。\n\n至此，我们已经理解了Invoke的具体实现。\n\n#### 事件委托的工作原理\n\n下面来看事件委托，为什么`Director.Test()`能够触发`director_OnReport()`回调函数。\n\n我们在`button1_Click()`函数中添加了回调`director.OnReport += director_OnReport;`于是`OnReport`事件执行了`add{_report += value;}`完成添加回调的过程。\n\n基于前面的现象我们知道`progressBar1`是在非窗体线程被更改的（见Invoke实现），既然是来自非窗体线程的更改，那么会不会是本来在窗体类中的`director_OnReport(string postStatus)`函数在回调绑定完成之后直接被替换到了`Director.Test()`中的`_report(counter.ToString());`呢？\n\n从表象上我们有理由怀疑这一点，那么实际验证一下吧。\n\n想了解其底层实现，我们先看看Director类的MSIL吧（话说MSIL现已被微软正名为CIL，微软之心昭然若揭。。。）\n\n`Director - MSIL`\n\n```MSIL\n.method public hidebysig specialname instance void \n        add_OnReport(class DelegateDemo.PostEventHandler 'value') cil managed\n{\n  // 代码大小       23 (0x17)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  ldsfld     class DelegateDemo.PostEventHandler DelegateDemo.Director::_report\n  IL_0006:  ldarg.1\n  IL_0007:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,\n                                                                                          class [mscorlib]System.Delegate)\n  IL_000c:  castclass  DelegateDemo.PostEventHandler\n  IL_0011:  stsfld     class DelegateDemo.PostEventHandler DelegateDemo.Director::_report\n  IL_0016:  ret\n} // end of method Director::add_OnReport\n\n.event DelegateDemo.PostEventHandler OnReport\n{\n  .addon instance void DelegateDemo.Director::add_OnReport(class DelegateDemo.PostEventHandler)\n  .removeon instance void DelegateDemo.Director::remove_OnReport(class DelegateDemo.PostEventHandler)\n} // end of event Director::OnReport\n```\n\n`OnReport`事件的内容被编译为两个函数。我们先只看`add_OnReport`这个函数，无非是与Property的Getter和Setter类似，对内绑定到`_report()`函数。那么再来看Form1中对`OnReport`事件的注册：\n\n`button1_Click - MSIL`\n\n```MSIL\n.method private hidebysig instance void  button1_Click(object sender,\n                                                       class [mscorlib]System.EventArgs e) cil managed\n{\n  // 代码大小       66 (0x42)\n  .maxstack  3\n  .locals init ([0] class DelegateDemo.Director director,\n           [1] class [mscorlib]System.Threading.Thread thread,\n           [2] class [mscorlib]System.Threading.Thread '<>g__initLocal0')\n  IL_0000:  nop\n  IL_0001:  newobj     instance void DelegateDemo.Director::.ctor()\n  IL_0006:  stloc.0\n  IL_0007:  ldloc.0\n  IL_0008:  ldarg.0\n  IL_0009:  ldftn      instance void DelegateDemo.Form1::director_OnReport(string)\n  IL_000f:  newobj     instance void DelegateDemo.PostEventHandler::.ctor(object,\n                                                                          native int)\n  IL_0014:  callvirt   instance void DelegateDemo.Director::add_OnReport(class DelegateDemo.PostEventHandler)\n  IL_0019:  nop\n  IL_001a:  ldnull\n  IL_001b:  ldftn      void DelegateDemo.Director::Test()\n  IL_0021:  newobj     instance void [mscorlib]System.Threading.ThreadStart::.ctor(object,\n                                                                                   native int)\n  IL_0026:  newobj     instance void [mscorlib]System.Threading.Thread::.ctor(class [mscorlib]System.Threading.ThreadStart)\n  IL_002b:  stloc.2\n  IL_002c:  ldloc.2\n  IL_002d:  ldstr      \"thdDirector\"\n  IL_0032:  callvirt   instance void [mscorlib]System.Threading.Thread::set_Name(string)\n  IL_0037:  nop\n  IL_0038:  ldloc.2\n  IL_0039:  stloc.1\n  IL_003a:  ldloc.1\n  IL_003b:  callvirt   instance void [mscorlib]System.Threading.Thread::Start()\n  IL_0040:  nop\n  IL_0041:  ret\n} // end of method Form1::button1_Click\n```\n\n其中`IL_0009:  ldftn`位置到`IL_000f:  newobj`位置声明并实例化了`director_OnReport`作为委托的target，而`IL_0014:  callvirt`位置调用了`add_OnReport()`进行实际意义上的绑定。\n\n然后从`IL_001b:  ldftn`位置开始实例化新线程并进行相关赋值操作，直到`IL_003b:  callvirt`位置调用`Thread::Start()`启动线程。\n\n这样我们已经基本理清了绑定的实现过程，但是代码在执行时是否如上面所说是“函数在回调绑定完成之后直接被替换”这样呢？想要验证就必须再看MSIL的底层实现，就是汇编啦。\n\n#### 事件委托的本质\n\n打开高端大气上档次的反汇编工具，在Director类中设定断点。\n\n这里我们主要看以下两处：\n\n断点0：行26: `add { _report += value; }`\n\n断点1：行35: `_report(counter.ToString(CultureInfo.InvariantCulture));`\n\n开始调试，点击button1，第一次中断在断点0处：\n\n`Director.cs - Asm`内容：（参考注释）\n\n```ASM\n--- Director.cs ----------------\n push        ebp  //各种压栈，为后面还原现场\n mov         ebp,esp \n push        edi \n push        esi \n push        ebx \n sub         esp,38h \n xor         eax,eax \n0000000b  mov         dword ptr [ebp-10h],eax \n0000000e  xor         eax,eax \n mov         dword ptr [ebp-1Ch],eax \n mov         dword ptr [ebp-3Ch],ecx \n mov         dword ptr [ebp-40h],edx \n cmp         dword ptr ds:[00289080h],0 \n je          00000027 \n call        78C0FD41 \n//这里开始对应 add { _report += value; }\n nop  //获得数据段地址寄存器偏移量02A184B8h（每次运行不同）处的值，赋给ecx寄存器，这个偏移量下面还会见到。\n mov         ecx,dword ptr ds:[02A184B8h] \n0000002e  mov         edx,dword ptr [ebp-40h] \n call        77EE1804  //调用Delegate Combine()\n mov         dword ptr [ebp-44h],eax \n cmp         dword ptr [ebp-44h],0 \n0000003d  je          0000005E \n0000003f  mov         eax,dword ptr [ebp-44h] \n cmp         dword ptr [eax],4430824h \n jne         0000004F \n0000004a  mov         eax,dword ptr [ebp-44h] \n0000004d  jmp         0000005C  //直接跳到00000061位置\n0000004f  mov         edx,dword ptr [ebp-44h] \n mov         ecx,4430824h \n call        7899A73E \n0000005c  jmp         00000061 \n0000005e  mov         eax,dword ptr [ebp-44h] \n lea         edx,ds:[02A184B8h] \n call        789911C8  //未跟踪\n0000006c  nop \n0000006d  lea         esp,[ebp-0Ch] \n pop         ebx \n pop         esi \n pop         edi \n pop         ebp \n ret  \n```\n\n其中Combine的代码我省略了。\n\n运行到断点1：\n\n`Director.cs - Asm`内容：\n\n```ASM\n--- Director.cs ----------------\n//对应_report(counter.ToString(CultureInfo.InvariantCulture));\n nop  //这个非常眼熟的偏移地址02A184B8h值又传送至eax寄存器，这个偏移就是数据段中的函数地址\n mov         eax,dword ptr ds:[02A184B8h] \n0000003e  mov         dword ptr [ebp-48h],eax \n lea         eax,[ebp-3Ch] \n mov         dword ptr [ebp-4Ch],eax \n call        77E72110  //这里构造了个CultureInfo\n0000004c  mov         dword ptr [ebp-50h],eax \n0000004f  mov         edx,dword ptr [ebp-50h] \n mov         ecx,dword ptr [ebp-4Ch] \n call        7838EDA4  //调用NumberFormatInfo(), 还是Culture类相关的，做了些i18n的事情\n0000005a  mov         dword ptr [ebp-54h],eax \n0000005d  mov         edx,dword ptr [ebp-54h] \n mov         ecx,dword ptr [ebp-48h] \n mov         eax,dword ptr [ecx+0Ch] \n mov         ecx,dword ptr [ecx+4] \n call        eax  //此时eax中的值就是ds:[02A184B8h]的值，call后直接来到director_OnReport()，见下。\n0000006b  nop\n```\n\n直接跳转到了函数`director_OnReport()`\n\n那就再来看`Form1.cs - Asm`\n\n```ASM\n// 从这是跳到函数director_OnReport()\n nop\n            //int value = Convert.ToInt32(postStatus);\n mov         ecx,dword ptr [ebp-40h] \n call        03B4E948 \n0000005b  mov         dword ptr [ebp-58h],eax \n0000005e  mov         eax,dword ptr [ebp-58h] \n mov         dword ptr [ebp-44h],eax \n            //这里是 if (this.progressBar1.InvokeRequired)\n mov         eax,dword ptr [ebp-3Ch] \n mov         ecx,dword ptr [eax+00000144h] \n0000006d  mov         eax,dword ptr [ecx] \n0000006f  call        dword ptr [eax+00000128h] \n mov         dword ptr [ebp-5Ch],eax \n cmp         dword ptr [ebp-5Ch],0 \n0000007c  sete        al \n0000007f  movzx       eax,al \n mov         dword ptr [ebp-50h],eax \n cmp         dword ptr [ebp-50h],0 \n jne         0000012D \n0000008f  nop \n```\n\n这就充分说明在C#代码层面上执行的`_report()`函数和`director_OnReport()`回调函数本质上是同一个函数（段地址相同），也恰好解释了为什么Form1类中的私有函数为什么可以在其他类调用\n。因为C#也好，CIL也好，都是表层的封装，而在CLR中真正运行的，是CLR Assembly.\n\n我们说CLR是虚拟机，这个“虚拟”仅仅指CLR中的指令并非与物理硬件相关联，但是指令集在虚拟机层面与x86 CPU的指令本质上是相同的。.NET美轮美奂的亭台楼榭都建立在汇编的一砖一瓦之上。而在CLR Assembly层面，只有内核级的概念，这也是我们能够看到其实质的原因。\n\n#### 总结\n\n好啦，总结起来C#的窗体事件本质上与MFC的窗体事件一样，都基于Windows API提供的窗体事件消息循环机制实现（主要实现是窗体消息队列）。\n\n为了更新控件又想要避免耗时操作导致卡顿，或者为了跨线程修改窗体控件，我们都可以用.NET提供的Invoke方法（或BeginInvoke）实现。这一方法本质上是通过加入消息至窗体消息循环来实现。\n\nC#事件委托绑定的回调在实现上就是调用同一函数，可以验证其在方法区上的地址相同。\n\n所以在使用.NET封装好的模块和功能模型时，如果能够同时理解其底层实现，相信会对软件开发工作大有裨益。 \n\n以及，要养成写博客的好习惯~\n\n#### 参考文献\n[^1]: [Race condition - Wikipedia](http://en.wikipedia.org/wiki/Race_condition)\n[^2]: [Control.CheckForIllegalCrossThreadCalls 属性 - MSDN](https://msdn.microsoft.com/zh-cn/library/system.windows.forms.control.checkforillegalcrossthreadcalls%28v=vs.110%29.aspx)\n[^3]: [Marshalling - (computer science)](http://en.wikipedia.org/wiki/Marshalling_%28computer_science%29)\n[^4]: [CWnd::PostMessage - MSDN](https://msdn.microsoft.com/en-us/library/9tdesxec.aspx)\n","html":"<h4 id=\"\">跨线程修改控件的问题</h4>\n\n<p>相信大家刚开始写winform的时候都遇到过这样的问题，当跨线程修改控件属性时会遇到如下的异常：</p>\n\n<blockquote>\n  <p>线程间操作无效: 从不是创建控件\"progressBar1\"的线程访问它。</p>\n</blockquote>\n\n<p>这是相应的产生上述异常的示例代码（注意事件响应部分）：</p>\n\n<p><code>Director.cs</code>的内容:</p>\n\n<pre><code class=\"language-C#\">// DelegateDemo - Director.cs\n// by Wings\n// Last Modified : 2013-05-28 11:43\n\nusing System.Globalization;  \nusing System.Threading;\n\nnamespace DelegateDemo  \n{\n    public delegate void PostEventHandler(string postStatus);\n\n    internal class Director\n    {\n        private static PostEventHandler _report;\n\n        public event PostEventHandler OnReport\n        {\n            add { _report += value; }\n            remove { _report -= value; }\n        }\n\n        public static void Test()\n        {\n            int counter = 0;\n            while (counter++ &lt; 100)\n            {\n                _report(counter.ToString());\n                Thread.Sleep(100);\n            }\n        }\n    }\n}\n</code></pre>\n\n<p><code>Form1.cs</code>的内容:</p>\n\n<pre><code class=\"language-C#\">  // DelegateDemo - Form1.cs\n  // by Wings\n  // Last Modified : 2013-05-27 19:54\n\n  using System;\n  using System.Threading;\n  using System.Windows.Forms;\n\n  namespace DelegateDemo\n  {\n      public partial class Form1 : Form\n      {\n          public Form1()\n          {\n              InitializeComponent();\n          }\n\n          private void button1_Click(object sender, EventArgs e)\n          {\n              Director director = new Director();\n              director.OnReport += director_OnReport;\n              Thread thread = new Thread(Director.Test)\n                              {\n                                  Name = \"thdDirector\"\n                              };\n              thread.Start();\n          }\n\n          private void director_OnReport(string postStatus)\n          {\n              int value = Convert.ToInt32(postStatus);\n              this.progressBar1.Value = value;  //此处产生异常\n          }\n      }\n  }\n</code></pre>\n\n<p>我们知道多线程下处于竞态条件（Race Condition<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\">1</a></sup>）的资源状态同步可能出现冲突。因此CLR才会禁止这种跨线程修改主窗体控件的行为。</p>\n\n<p>一个简单粗暴（但十分有效）的方法是在主窗体构造函数中加入\n<code>CheckForIllegalCrossThreadCalls = false;</code></p>\n\n<p>像这样：</p>\n\n<pre><code class=\"language-C#\">public Form1()  \n{            \n    InitializeComponent();\n    CheckForIllegalCrossThreadCalls = false;\n}\n</code></pre>\n\n<p>附上msdn的解释<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\">2</a></sup>：</p>\n\n<blockquote>\n  <p>CheckForIllegalCrossThreadCalls: 获取或设置一个值，该值指示是否捕获对错误线程的调用，这些调用在调试应用程序时访问控件的 Handle 属性。\n  因此设为false后将不再检查非法跨线程调用。 </p>\n</blockquote>\n\n<p>然而毕竟跨线程调用是不安全的，可能导致同步失败。所以我们采用正统一点的方法来解决，那就是调用控件的<code>Invoke()</code>或<code>BeginInvoke()</code>方法。</p>\n\n<p>二者的差别在于<code>BeginInvoke()</code>是异步的，这里为了防止<code>Director.Test()</code>执行时主窗体关闭导致句柄失效而产生异常，我们使用<code>BeginInvoke()</code>方法进行异步调用。</p>\n\n<h4 id=\"invoke\">通过Invoke解决问题</h4>\n\n<p>更改过的<code>Form1.cs</code>:</p>\n\n<pre><code class=\"language-C#\"> // DelegateDemo - Form1.cs\n // by Wings\n // Last Modified : 2013-05-28 13:06\n\n using System;\n using System.Threading;\n using System.Windows.Forms;\n\n namespace DelegateDemo\n {\n     public partial class Form1 : Form\n     {\n         public Form1()\n         {\n             InitializeComponent();\n         }\n\n         private void button1_Click(object sender, EventArgs e)\n         {\n             Director director = new Director();\n             director.OnReport += director_OnReport;\n             Thread thread = new Thread(Director.Test)\n                             {\n                                 Name = \"thdDirector\"\n                             };\n             thread.Start();\n         }\n\n         private void director_OnReport(string postStatus)\n         {\n             int value = Convert.ToInt32(postStatus);\n             if (this.progressBar1.InvokeRequired)\n             {\n                 SetValueCallback setValueCallback = delegate(int i)\n                                                     {\n                                                         this.progressBar1.Value = i;\n                                                     };\n                 this.progressBar1.BeginInvoke(setValueCallback, value);\n             }\n             else\n             {\n                 this.progressBar1.Value = value;\n             }\n         }\n\n         private delegate void SetValueCallback(int value);\n     }\n }\n</code></pre>\n\n<p>至此，问题已经彻底解决，本文也可以结束了。</p>\n\n<p>但是！！！我们都知道一个不想当Geek的码农不是合格的程序猿~</p>\n\n<p>于是再次发扬Geek精神，尝试剥去.NET粉饰的外衣，窥其真理的内核。</p>\n\n<h4 id=\"\">源码分析</h4>\n\n<p>先从<code>Invoke()</code>入手，看源码：</p>\n\n<pre><code class=\"language-C#\">public object Invoke(Delegate method, params object[] args)  \n{\n    using (new Control.MultithreadSafeCallScope())\n    return this.FindMarshalingControl().MarshaledInvoke(this, method, args, true);\n}\n</code></pre>\n\n<p>而<code>BeginInvoke()</code>差别仅仅在于<code>MarshaledInvoke()</code>的参数是否<code>synchronous</code>:</p>\n\n<pre><code class=\"language-C#\">public IAsyncResult BeginInvoke(Delegate method, params object[] args)  \n{\n      using (new Control.MultithreadSafeCallScope())\n        return (IAsyncResult) this.FindMarshalingControl().MarshaledInvoke(this, method, args, false);\n}\n</code></pre>\n\n<p>实质都是调用了<code>MarshaledInvoke</code>方法。</p>\n\n<p>Marshaled这个词常写Native Methods的同学一定很熟悉。对应的中文翻译我。。不知道。。 貌似是叫“编组”。</p>\n\n<p>给出维基百科的释义<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\">3</a></sup>作为参考吧：</p>\n\n<blockquote>\n  <p>In computer science, marshalling (sometimes spelled marshaling with a single l) is the process of transforming the memory representation of an object to a data format suitable for storage or transmission, and it is typically used when data must be moved between different parts of a computer program or from one program to another. Marshalling is similar to serialization and is used to communicate to remote objects with an object, in this case a serialized object. It simplifies complex communication, using custom/complex objects to communicate instead of primitives. The opposite, or reverse, of marshalling is called unmarshalling (or demarshalling, similar to deserialization).</p>\n</blockquote>\n\n<p>所以.NET的“暗箱操作”很有可能就在<code>MarshaledInvoke</code>里面。我们点进去看一下，当然主要关注NativeMethods</p>\n\n<pre><code class=\"language-C#\">private object MarshaledInvoke(Control caller, Delegate method, object[] args, bool synchronous)  \n    {\n      if (!this.IsHandleCreated)\n        throw new InvalidOperationException(System.Windows.Forms.SR.GetString(\"ErrorNoMarshalingThread\"));\n      if ((Control.ActiveXImpl) this.Properties.GetObject(Control.PropActiveXImpl) != null)\n        System.Windows.Forms.IntSecurity.UnmanagedCode.Demand();\n      bool flag = false;\n      int lpdwProcessId;\n      if (System.Windows.Forms.SafeNativeMethods.GetWindowThreadProcessId(new HandleRef((object) this, this.Handle), out lpdwProcessId) == System.Windows.Forms.SafeNativeMethods.GetCurrentThreadId() &amp;&amp; synchronous)\n        flag = true;\n      ExecutionContext executionContext = (ExecutionContext) null;\n      if (!flag)\n        executionContext = ExecutionContext.Capture();\n      Control.ThreadMethodEntry threadMethodEntry = new Control.ThreadMethodEntry(caller, this, method, args, synchronous, executionContext);\n      lock (this)\n      {\n        if (this.threadCallbackList == null)\n          this.threadCallbackList = new Queue();\n      }\n      lock (this.threadCallbackList)\n      {\n        if (Control.threadCallbackMessage == 0)\n          Control.threadCallbackMessage = System.Windows.Forms.SafeNativeMethods.RegisterWindowMessage(Application.WindowMessagesVersion + \"_ThreadCallbackMessage\");\n        this.threadCallbackList.Enqueue((object) threadMethodEntry);\n      }\n      if (flag)\n        this.InvokeMarshaledCallbacks();\n      else\n       // 这里就是纯天然原生态NativeMethod\n      System.Windows.Forms.UnsafeNativeMethods.PostMessage(new HandleRef((object) this, this.Handle), Control.threadCallbackMessage, IntPtr.Zero, IntPtr.Zero);\n      if (!synchronous)\n        return (object) threadMethodEntry;\n      if (!threadMethodEntry.IsCompleted)\n        this.WaitForWaitHandle(threadMethodEntry.AsyncWaitHandle);\n      if (threadMethodEntry.exception != null)\n        throw threadMethodEntry.exception;\n      else\n        return threadMethodEntry.retVal;\n}\n</code></pre>\n\n<p>果然找到了，这个<code>System.Windows.Forms.UnsafeNativeMethods.PostMessage()</code>就是WinAPI封装过后的NativeMethod了。当然它披上另一件衣服之后也是MFC里面的<code>CWnd::PostMessage</code>, 负责向窗体消息队列中放置一条消息，并且不等待消息被处理而直接返回（异步也是与<code>SendMessage</code>的主要差别）。</p>\n\n<p>MSDN文档<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\">4</a></sup>：  </p>\n\n<blockquote>\n  <p>Places a message in the window's message queue and then returns without waiting for the corresponding window to process the message.</p>\n</blockquote>\n\n<p>这也就解释了上述情况发生的原因，调用<code>Invoke()</code>而不是直接更改控件值使得主窗体能够将消息加入自身的消息队列中，从而在合适的时间处理消息，这样跨线程更改控件值就转变为窗体线程自己更改控件值，也就是从创建控件的线程（窗体主线程）访问控件，避免了之前的错误。</p>\n\n<h4 id=\"invokerequired\">InvokeRequired属性探究</h4>\n\n<p>还有一个问题，如果本来就是窗体线程对控件进行访问呢，毫无疑问直接设置值即可。在上面的代码中我使用InvokeRequired属性来判断控件更改者是否来自于其他线程，从而决定是调<code>Invoke()</code>还是直接改。那么这个属性是否真的如我们所想，仅仅是判断调用者线程呢？看代码：</p>\n\n<p><code>InvokeRequired:</code></p>\n\n<pre><code class=\"language-C#\">[SRDescription(\"ControlInvokeRequiredDescr\")]\n[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]\n[Browsable(false)]\n[EditorBrowsable(EditorBrowsableState.Advanced)]\npublic bool InvokeRequired  \n{\n      get\n      {\n        using (new Control.MultithreadSafeCallScope())\n        {\n          HandleRef hWnd;\n          if (this.IsHandleCreated)\n          {\n            hWnd = new HandleRef((object) this, this.Handle);\n          }\n          else\n          {\n            Control marshalingControl = this.FindMarshalingControl();\n            if (!marshalingControl.IsHandleCreated)\n              return false;\n            hWnd = new HandleRef((object) marshalingControl, marshalingControl.Handle);\n          }\n          int lpdwProcessId;\n          return System.Windows.Forms.SafeNativeMethods.GetWindowThreadProcessId(hWnd, out lpdwProcessId) != System.Windows.Forms.SafeNativeMethods.GetCurrentThreadId();\n        }\n      }\n    }\n</code></pre>\n\n<p>果然如此，最后的return写得很清楚。</p>\n\n<p>至此，我们已经理解了Invoke的具体实现。</p>\n\n<h4 id=\"\">事件委托的工作原理</h4>\n\n<p>下面来看事件委托，为什么<code>Director.Test()</code>能够触发<code>director_OnReport()</code>回调函数。</p>\n\n<p>我们在<code>button1_Click()</code>函数中添加了回调<code>director.OnReport += director_OnReport;</code>于是<code>OnReport</code>事件执行了<code>add{_report += value;}</code>完成添加回调的过程。</p>\n\n<p>基于前面的现象我们知道<code>progressBar1</code>是在非窗体线程被更改的（见Invoke实现），既然是来自非窗体线程的更改，那么会不会是本来在窗体类中的<code>director_OnReport(string postStatus)</code>函数在回调绑定完成之后直接被替换到了<code>Director.Test()</code>中的<code>_report(counter.ToString());</code>呢？</p>\n\n<p>从表象上我们有理由怀疑这一点，那么实际验证一下吧。</p>\n\n<p>想了解其底层实现，我们先看看Director类的MSIL吧（话说MSIL现已被微软正名为CIL，微软之心昭然若揭。。。）</p>\n\n<p><code>Director - MSIL</code></p>\n\n<pre><code class=\"language-MSIL\">.method public hidebysig specialname instance void \n        add_OnReport(class DelegateDemo.PostEventHandler 'value') cil managed\n{\n  // 代码大小       23 (0x17)\n  .maxstack  8\n  IL_0000:  nop\n  IL_0001:  ldsfld     class DelegateDemo.PostEventHandler DelegateDemo.Director::_report\n  IL_0006:  ldarg.1\n  IL_0007:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,\n                                                                                          class [mscorlib]System.Delegate)\n  IL_000c:  castclass  DelegateDemo.PostEventHandler\n  IL_0011:  stsfld     class DelegateDemo.PostEventHandler DelegateDemo.Director::_report\n  IL_0016:  ret\n} // end of method Director::add_OnReport\n\n.event DelegateDemo.PostEventHandler OnReport\n{\n  .addon instance void DelegateDemo.Director::add_OnReport(class DelegateDemo.PostEventHandler)\n  .removeon instance void DelegateDemo.Director::remove_OnReport(class DelegateDemo.PostEventHandler)\n} // end of event Director::OnReport\n</code></pre>\n\n<p><code>OnReport</code>事件的内容被编译为两个函数。我们先只看<code>add_OnReport</code>这个函数，无非是与Property的Getter和Setter类似，对内绑定到<code>_report()</code>函数。那么再来看Form1中对<code>OnReport</code>事件的注册：</p>\n\n<p><code>button1_Click - MSIL</code></p>\n\n<pre><code class=\"language-MSIL\">.method private hidebysig instance void  button1_Click(object sender,\n                                                       class [mscorlib]System.EventArgs e) cil managed\n{\n  // 代码大小       66 (0x42)\n  .maxstack  3\n  .locals init ([0] class DelegateDemo.Director director,\n           [1] class [mscorlib]System.Threading.Thread thread,\n           [2] class [mscorlib]System.Threading.Thread '&lt;&gt;g__initLocal0')\n  IL_0000:  nop\n  IL_0001:  newobj     instance void DelegateDemo.Director::.ctor()\n  IL_0006:  stloc.0\n  IL_0007:  ldloc.0\n  IL_0008:  ldarg.0\n  IL_0009:  ldftn      instance void DelegateDemo.Form1::director_OnReport(string)\n  IL_000f:  newobj     instance void DelegateDemo.PostEventHandler::.ctor(object,\n                                                                          native int)\n  IL_0014:  callvirt   instance void DelegateDemo.Director::add_OnReport(class DelegateDemo.PostEventHandler)\n  IL_0019:  nop\n  IL_001a:  ldnull\n  IL_001b:  ldftn      void DelegateDemo.Director::Test()\n  IL_0021:  newobj     instance void [mscorlib]System.Threading.ThreadStart::.ctor(object,\n                                                                                   native int)\n  IL_0026:  newobj     instance void [mscorlib]System.Threading.Thread::.ctor(class [mscorlib]System.Threading.ThreadStart)\n  IL_002b:  stloc.2\n  IL_002c:  ldloc.2\n  IL_002d:  ldstr      \"thdDirector\"\n  IL_0032:  callvirt   instance void [mscorlib]System.Threading.Thread::set_Name(string)\n  IL_0037:  nop\n  IL_0038:  ldloc.2\n  IL_0039:  stloc.1\n  IL_003a:  ldloc.1\n  IL_003b:  callvirt   instance void [mscorlib]System.Threading.Thread::Start()\n  IL_0040:  nop\n  IL_0041:  ret\n} // end of method Form1::button1_Click\n</code></pre>\n\n<p>其中<code>IL_0009:  ldftn</code>位置到<code>IL_000f:  newobj</code>位置声明并实例化了<code>director_OnReport</code>作为委托的target，而<code>IL_0014:  callvirt</code>位置调用了<code>add_OnReport()</code>进行实际意义上的绑定。</p>\n\n<p>然后从<code>IL_001b:  ldftn</code>位置开始实例化新线程并进行相关赋值操作，直到<code>IL_003b:  callvirt</code>位置调用<code>Thread::Start()</code>启动线程。</p>\n\n<p>这样我们已经基本理清了绑定的实现过程，但是代码在执行时是否如上面所说是“函数在回调绑定完成之后直接被替换”这样呢？想要验证就必须再看MSIL的底层实现，就是汇编啦。</p>\n\n<h4 id=\"\">事件委托的本质</h4>\n\n<p>打开高端大气上档次的反汇编工具，在Director类中设定断点。</p>\n\n<p>这里我们主要看以下两处：</p>\n\n<p>断点0：行26: <code>add { _report += value; }</code></p>\n\n<p>断点1：行35: <code>_report(counter.ToString(CultureInfo.InvariantCulture));</code></p>\n\n<p>开始调试，点击button1，第一次中断在断点0处：</p>\n\n<p><code>Director.cs - Asm</code>内容：（参考注释）</p>\n\n<pre><code class=\"language-ASM\">--- Director.cs ----------------\n push        ebp  //各种压栈，为后面还原现场\n mov         ebp,esp \n push        edi \n push        esi \n push        ebx \n sub         esp,38h \n xor         eax,eax \n0000000b  mov         dword ptr [ebp-10h],eax  \n0000000e  xor         eax,eax  \n mov         dword ptr [ebp-1Ch],eax \n mov         dword ptr [ebp-3Ch],ecx \n mov         dword ptr [ebp-40h],edx \n cmp         dword ptr ds:[00289080h],0 \n je          00000027 \n call        78C0FD41 \n//这里开始对应 add { _report += value; }\n nop  //获得数据段地址寄存器偏移量02A184B8h（每次运行不同）处的值，赋给ecx寄存器，这个偏移量下面还会见到。\n mov         ecx,dword ptr ds:[02A184B8h] \n0000002e  mov         edx,dword ptr [ebp-40h]  \n call        77EE1804  //调用Delegate Combine()\n mov         dword ptr [ebp-44h],eax \n cmp         dword ptr [ebp-44h],0 \n0000003d  je          0000005E  \n0000003f  mov         eax,dword ptr [ebp-44h]  \n cmp         dword ptr [eax],4430824h \n jne         0000004F \n0000004a  mov         eax,dword ptr [ebp-44h]  \n0000004d  jmp         0000005C  //直接跳到00000061位置  \n0000004f  mov         edx,dword ptr [ebp-44h]  \n mov         ecx,4430824h \n call        7899A73E \n0000005c  jmp         00000061  \n0000005e  mov         eax,dword ptr [ebp-44h]  \n lea         edx,ds:[02A184B8h] \n call        789911C8  //未跟踪\n0000006c  nop  \n0000006d  lea         esp,[ebp-0Ch]  \n pop         ebx \n pop         esi \n pop         edi \n pop         ebp \n ret  \n</code></pre>\n\n<p>其中Combine的代码我省略了。</p>\n\n<p>运行到断点1：</p>\n\n<p><code>Director.cs - Asm</code>内容：</p>\n\n<pre><code class=\"language-ASM\">--- Director.cs ----------------\n//对应_report(counter.ToString(CultureInfo.InvariantCulture));\n nop  //这个非常眼熟的偏移地址02A184B8h值又传送至eax寄存器，这个偏移就是数据段中的函数地址\n mov         eax,dword ptr ds:[02A184B8h] \n0000003e  mov         dword ptr [ebp-48h],eax  \n lea         eax,[ebp-3Ch] \n mov         dword ptr [ebp-4Ch],eax \n call        77E72110  //这里构造了个CultureInfo\n0000004c  mov         dword ptr [ebp-50h],eax  \n0000004f  mov         edx,dword ptr [ebp-50h]  \n mov         ecx,dword ptr [ebp-4Ch] \n call        7838EDA4  //调用NumberFormatInfo(), 还是Culture类相关的，做了些i18n的事情\n0000005a  mov         dword ptr [ebp-54h],eax  \n0000005d  mov         edx,dword ptr [ebp-54h]  \n mov         ecx,dword ptr [ebp-48h] \n mov         eax,dword ptr [ecx+0Ch] \n mov         ecx,dword ptr [ecx+4] \n call        eax  //此时eax中的值就是ds:[02A184B8h]的值，call后直接来到director_OnReport()，见下。\n0000006b  nop  \n</code></pre>\n\n<p>直接跳转到了函数<code>director_OnReport()</code></p>\n\n<p>那就再来看<code>Form1.cs - Asm</code></p>\n\n<pre><code class=\"language-ASM\">// 从这是跳到函数director_OnReport()\n nop\n            //int value = Convert.ToInt32(postStatus);\n mov         ecx,dword ptr [ebp-40h] \n call        03B4E948 \n0000005b  mov         dword ptr [ebp-58h],eax  \n0000005e  mov         eax,dword ptr [ebp-58h]  \n mov         dword ptr [ebp-44h],eax \n            //这里是 if (this.progressBar1.InvokeRequired)\n mov         eax,dword ptr [ebp-3Ch] \n mov         ecx,dword ptr [eax+00000144h] \n0000006d  mov         eax,dword ptr [ecx]  \n0000006f  call        dword ptr [eax+00000128h]  \n mov         dword ptr [ebp-5Ch],eax \n cmp         dword ptr [ebp-5Ch],0 \n0000007c  sete        al  \n0000007f  movzx       eax,al  \n mov         dword ptr [ebp-50h],eax \n cmp         dword ptr [ebp-50h],0 \n jne         0000012D \n0000008f  nop  \n</code></pre>\n\n<p>这就充分说明在C#代码层面上执行的<code>_report()</code>函数和<code>director_OnReport()</code>回调函数本质上是同一个函数（段地址相同），也恰好解释了为什么Form1类中的私有函数为什么可以在其他类调用\n。因为C#也好，CIL也好，都是表层的封装，而在CLR中真正运行的，是CLR Assembly.</p>\n\n<p>我们说CLR是虚拟机，这个“虚拟”仅仅指CLR中的指令并非与物理硬件相关联，但是指令集在虚拟机层面与x86 CPU的指令本质上是相同的。.NET美轮美奂的亭台楼榭都建立在汇编的一砖一瓦之上。而在CLR Assembly层面，只有内核级的概念，这也是我们能够看到其实质的原因。</p>\n\n<h4 id=\"\">总结</h4>\n\n<p>好啦，总结起来C#的窗体事件本质上与MFC的窗体事件一样，都基于Windows API提供的窗体事件消息循环机制实现（主要实现是窗体消息队列）。</p>\n\n<p>为了更新控件又想要避免耗时操作导致卡顿，或者为了跨线程修改窗体控件，我们都可以用.NET提供的Invoke方法（或BeginInvoke）实现。这一方法本质上是通过加入消息至窗体消息循环来实现。</p>\n\n<p>C#事件委托绑定的回调在实现上就是调用同一函数，可以验证其在方法区上的地址相同。</p>\n\n<p>所以在使用.NET封装好的模块和功能模型时，如果能够同时理解其底层实现，相信会对软件开发工作大有裨益。 </p>\n\n<p>以及，要养成写博客的好习惯~</p>\n\n<h4 id=\"\">参考文献</h4>\n\n<div class=\"footnotes\"><ol><li class=\"footnote\" id=\"fn:1\"><p><a href=\"http://en.wikipedia.org/wiki/Race_condition\">Race condition - Wikipedia</a> <a href=\"#fnref:1\" title=\"return to article\">↩</a></p></li>\n<li class=\"footnote\" id=\"fn:2\"><p><a href=\"https://msdn.microsoft.com/zh-cn/library/system.windows.forms.control.checkforillegalcrossthreadcalls%28v=vs.110%29.aspx\">Control.CheckForIllegalCrossThreadCalls 属性 - MSDN</a> <a href=\"#fnref:2\" title=\"return to article\">↩</a></p></li>\n<li class=\"footnote\" id=\"fn:3\"><p><a href=\"http://en.wikipedia.org/wiki/Marshalling_%28computer_science%29\">Marshalling - (computer science)</a> <a href=\"#fnref:3\" title=\"return to article\">↩</a></p></li>\n<li class=\"footnote\" id=\"fn:4\"><p><a href=\"https://msdn.microsoft.com/en-us/library/9tdesxec.aspx\">CWnd::PostMessage - MSDN</a> <a href=\"#fnref:4\" title=\"return to article\">↩</a></p></li></ol></div>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":"","author_id":1,"created_at":"2015-06-01T10:58:25.000Z","created_by":1,"updated_at":"2015-06-02T06:29:26.000Z","updated_by":1,"published_at":"2015-06-01T16:13:18.000Z","published_by":1}],"posts_tags":[{"id":10,"post_id":1,"tag_id":1},{"id":17,"post_id":2,"tag_id":2},{"id":19,"post_id":3,"tag_id":8},{"id":20,"post_id":3,"tag_id":9},{"id":22,"post_id":4,"tag_id":4}],"roles":[{"id":1,"uuid":"dcb16d97-cf48-483e-96d5-14fa3ea5f2b0","name":"Administrator","description":"Administrators","created_at":"2015-05-20T13:04:02.000Z","created_by":1,"updated_at":"2015-05-20T13:04:02.000Z","updated_by":1},{"id":2,"uuid":"ab7a8572-591d-4b62-a8e6-d53fd0695b4c","name":"Editor","description":"Editors","created_at":"2015-05-20T13:04:02.000Z","created_by":1,"updated_at":"2015-05-20T13:04:02.000Z","updated_by":1},{"id":3,"uuid":"9128e7b5-29ef-404b-82eb-a1626cde703a","name":"Author","description":"Authors","created_at":"2015-05-20T13:04:02.000Z","created_by":1,"updated_at":"2015-05-20T13:04:02.000Z","updated_by":1},{"id":4,"uuid":"dd7e9008-03b2-43c1-b196-8ca7e91e98d0","name":"Owner","description":"Blog Owner","created_at":"2015-05-20T13:04:02.000Z","created_by":1,"updated_at":"2015-05-20T13:04:02.000Z","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"settings":[{"id":1,"uuid":"66d3226a-27c4-4840-a5f7-17a09fd49d30","key":"databaseVersion","value":"003","type":"core","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-20T13:04:06.000Z","updated_by":1},{"id":2,"uuid":"52c4263b-78f9-4984-9c9c-c228db7ea958","key":"dbHash","value":"ebf63dab-8038-4839-956f-d884fc33a6f7","type":"core","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-20T13:04:06.000Z","updated_by":1},{"id":3,"uuid":"69f4cca1-ba3a-4e21-a940-a80026ca0476","key":"nextUpdateCheck","value":"1433829857","type":"core","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-06-08T06:04:17.000Z","updated_by":1},{"id":4,"uuid":"fcf5a028-30ce-4709-a4b0-b4ffc446f0ff","key":"displayUpdateNotification","value":"0.5.0","type":"core","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-06-08T06:04:17.000Z","updated_by":1},{"id":5,"uuid":"da8d4029-8a3e-4e84-84f2-6527ba476e98","key":"title","value":"Practice makes perfect.","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":6,"uuid":"c9a7aee6-01ee-4802-b468-405856123762","key":"description","value":"The wheels I reinvented  - Qiushi 's blog","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":7,"uuid":"7a601309-b0a8-4b0c-91ae-4154ad9abfda","key":"email","value":"wenqs27@gmail.com","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":8,"uuid":"5d9b2f0f-8084-411e-b067-1eccf963e686","key":"logo","value":"","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":9,"uuid":"f713a0ed-9af4-41c3-87e2-fa79255bd1d1","key":"cover","value":"http://img.blog.csdn.net/20150527194524765","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":10,"uuid":"db4deb14-729a-485a-93c0-04f8509f4739","key":"defaultLang","value":"en_US","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":11,"uuid":"3d7cfc3e-c97a-4fe3-ac4e-3597758b8c40","key":"postsPerPage","value":"10","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":12,"uuid":"3a6fd6eb-4005-4355-98ca-4d5003ef9ced","key":"forceI18n","value":"true","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":13,"uuid":"ec7d4949-9f2c-48e8-9ae8-da531646693c","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":14,"uuid":"c9353032-fa46-491d-a1da-e55352bea8cd","key":"ghost_head","value":"","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":15,"uuid":"1a6b0edc-ec94-4df8-b6d1-748d42275b78","key":"ghost_foot","value":"<script type=\"text/javascript\">\n    $('.site-footer').prepend('<div class=\"post\"> <footer class=\"post-footer\"> <p> <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\"> <img alt=\"知识共享许可协议\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc/4.0/88x31.png\"> </a> <br> 除特殊说明，本站作品均由<a xmlns:cc=\"http://creativecommons.org/ns#\" href=\"http://wenqiushi.daoapp.io\" property=\"cc:attributionName\" rel=\"cc:attributionURL\">wenqs</a>创作，并采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。 <br> Unless otherwise noted, content on <a xmlns:cc=\"http://creativecommons.org/ns#\" href=\"http://wenqiushi.daoapp.io\" property=\"cc:attributionName\" rel=\"cc:attributionURL\">this site</a> is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\">Creative Commons Attribution-NonCommercial 4.0 International License</a>. <br> </p> </footer> </div>');\n</script>\n","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":16,"uuid":"e2a73c9b-d791-4bcf-88bb-6ce367bbeab1","key":"labs","value":"{}","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":17,"uuid":"f86e01a4-54c9-46e7-a7f6-78f376f357fd","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"/\"},{\"label\":\"linux\",\"url\":\"/tag/linux/\"},{\"label\":\"git\",\"url\":\"/tag/git/\"},{\"label\":\"Java\",\"url\":\"/tag/java/\"},{\"label\":\".NET\",\"url\":\"/tag/dot-net/\"},{\"label\":\"python\",\"url\":\"/tag/python/\"},{\"label\":\"groovy\",\"url\":\"/tag/groovy/\"}]","type":"blog","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1},{"id":18,"uuid":"cad75922-1066-4435-8a56-c8e7edfd8cc3","key":"activeApps","value":"[]","type":"app","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-20T13:04:06.000Z","updated_by":1},{"id":19,"uuid":"e2664d25-a075-49cb-9d80-705f34f56c38","key":"installedApps","value":"[]","type":"app","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-06-08T11:56:07.000Z","updated_by":1},{"id":20,"uuid":"4186b5cc-b17d-4238-a021-63caec78b43e","key":"activeTheme","value":"casper","type":"theme","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-05-27T16:06:33.000Z","updated_by":1}],"tags":[{"id":1,"uuid":"558e19f7-4703-435d-8fb4-b04440a64b69","name":"Getting Started","slug":"getting-started","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-05-20T13:04:02.000Z","created_by":1,"updated_at":"2015-05-20T13:04:02.000Z","updated_by":1},{"id":2,"uuid":"d8ffdb90-ce32-4bb4-b6a2-28a469dd6b15","name":"linux","slug":"linux","description":"","image":"http://upload.wikimedia.org/wikipedia/commons/archive/b/b0/20060213062257%21NewTux.svg","hidden":0,"parent_id":null,"meta_title":"blogs about linux","meta_description":"","created_at":"2015-05-21T12:48:09.000Z","created_by":1,"updated_at":"2015-05-21T12:57:47.000Z","updated_by":1},{"id":3,"uuid":"c0170834-57ce-440d-afc3-904e5ec69ad7","name":"git","slug":"git","description":"","image":"http://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/320px-Git-logo.svg.png","hidden":0,"parent_id":null,"meta_title":"blogs about git","meta_description":null,"created_at":"2015-05-21T12:49:04.000Z","created_by":1,"updated_at":"2015-05-21T12:54:46.000Z","updated_by":1},{"id":4,"uuid":"c8b881d7-ce4a-4747-86ee-6c770e7bad19","name":".NET","slug":"dot-net","description":"","image":"http://upload.wikimedia.org/wikipedia/commons/5/52/Microsoft_NET_logo_old.svg","hidden":0,"parent_id":null,"meta_title":"blogs about .NET C# WPF","meta_description":null,"created_at":"2015-05-21T13:08:01.000Z","created_by":1,"updated_at":"2015-05-21T13:08:59.000Z","updated_by":1},{"id":5,"uuid":"169729b3-8a41-4ab6-af7a-5717e5dcaa67","name":"Java","slug":"java","description":"","image":"http://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Java_logo_and_wordmark.svg/262px-Java_logo_and_wordmark.svg.png","hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-05-21T13:09:09.000Z","created_by":1,"updated_at":"2015-05-21T13:23:47.000Z","updated_by":1},{"id":6,"uuid":"60135293-ad82-41d3-a3b3-749d9df98edd","name":"groovy","slug":"groovy","description":"","image":"http://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Groovy-logo.svg/640px-Groovy-logo.svg.png","hidden":0,"parent_id":null,"meta_title":"blogs about groovy and grails","meta_description":null,"created_at":"2015-05-21T13:12:58.000Z","created_by":1,"updated_at":"2015-05-21T13:13:16.000Z","updated_by":1},{"id":7,"uuid":"0091ae9f-ee37-42be-a9a2-04f4d2d47f9b","name":"python","slug":"python","description":"","image":"http://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/480px-Python-logo-notext.svg.png","hidden":0,"parent_id":null,"meta_title":"blogs about python","meta_description":null,"created_at":"2015-05-21T13:19:47.000Z","created_by":1,"updated_at":"2015-05-21T13:19:58.000Z","updated_by":1},{"id":8,"uuid":"5030e62e-ccfb-4ea0-aca1-f33ad6b71c59","name":"Misc","slug":"misc","description":"","image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-06-01T16:18:00.000Z","created_by":1,"updated_at":"2015-06-01T16:18:20.000Z","updated_by":1},{"id":9,"uuid":"e9199ca5-1050-40a3-8889-774b9717ea7a","name":"Windows","slug":"windows","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-06-01T16:19:18.000Z","created_by":1,"updated_at":"2015-06-01T16:19:18.000Z","updated_by":1}],"users":[{"id":1,"uuid":"fe97f8a5-dfee-4c0f-bf76-3588564529fd","name":"Wen Qiushi","slug":"wen","password":"$2a$10$OwMKPNr0DlwpWnTqAGqjiuxeijkGm6N.wa8LdXvT7XN0d/wt36J4i","email":"wenqs27@163.com","image":null,"cover":"","bio":"Java & .NET developer. Love cooking and coding.","website":"","location":"Guangzhou, China","accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"last_login":"2015-06-08T11:57:37.000Z","created_at":"2015-05-20T13:04:06.000Z","created_by":1,"updated_at":"2015-06-08T11:57:37.000Z","updated_by":1}]}}]}